<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Inline AR Example</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; }
    #model-buttons, #order-button-container {
      position: absolute;
      width: 100%; text-align: center;
      z-index: 10;
      display: none;
    }
    #model-buttons { bottom: 20px; }
    #order-button-container { bottom: 70px; }
    #model-buttons button,
    #order-button {
      padding: 10px 20px; font-size: 16px;
      margin: 0 10px; border: none; border-radius: 6px;
      background: rgba(255,255,255,0.9); cursor: pointer;
    }
    #order-button { background: #007bff; color: white; }
    #start-ar {
      position: absolute; top: 10px; left: 50%;
      transform: translateX(-50%);
      padding: 10px 20px; font-size: 16px;
      border: none; border-radius: 6px;
      background: #28a745; color: white; z-index: 10;
      cursor: pointer;
    }
  </style>
  <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/examples/jsm/loaders/GLTFLoader.js": "https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js"
    }
  }
  </script>
</head>
<body>

  <button id="start-ar">Start AR</button>
  <div id="model-buttons"></div>
  <div id="order-button-container">
    <button id="order-button">To order</button>
  </div>

  <script type="module">
  import * as THREE from 'three';
  import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';

  let camera, scene, renderer, controller, reticle;
  let hitTestSource = null, hitTestSourceRequested = false;
  let modelList = [], modelObjects = [], placedModel = null;
  const loader = new GLTFLoader();
  const urlParams = new URLSearchParams(location.search);
  const configUrl = urlParams.get('config');
  const byUrl = urlParams.get('byUrl');

  if (!configUrl) {
    alert("Missing ?config= parameter");
    throw new Error("Missing config");
  }

  fetch(configUrl)
    .then(r=>r.json())
    .then(cfg => {
      modelList = cfg.models;
      return Promise.all(modelList.map(e=>new Promise(res=>{
        loader.load(e.url, gltf=>{
          let m = gltf.scene; m.scale.set(1,1,1);
          modelObjects.push(m); res();
        },null,err=>{
          console.error(err);
          modelObjects.push(null); res();
        });
      })));
    })
    .then(() => init())
    .catch(e=>{ console.error(e); alert("Failed to load config"); });

  function init() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.01, 20);
    scene.add(new THREE.HemisphereLight(0xffffff,0xbbbbff,1));

    renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);

    // власний inline AR
    const btn = document.getElementById('start-ar');
    btn.addEventListener('click', async ()=>{
      const session = await navigator.xr.requestSession('inline', {
        requiredFeatures: ['hit-test']
      });
      renderer.xr.setSession(session);
      btn.style.display = 'none';
      animate();
    });

    // ретикл
    const ring = new THREE.RingGeometry(0.05,0.06,32).rotateX(-Math.PI/2);
    reticle = new THREE.Mesh(ring, new THREE.MeshBasicMaterial({ color:0x00ff00 }));
    reticle.matrixAutoUpdate = false; reticle.visible = false;
    scene.add(reticle);

    controller = renderer.xr.getController(0);
    controller.addEventListener('select', onSelect);
    scene.add(controller);

    window.addEventListener('resize', ()=>{
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  }

  function onSelect() {
    if (!reticle.visible || placedModel) return;
    const base = modelObjects[0];
    if (!base) { alert("Model load error"); return; }
    placedModel = base.clone();
    placedModel.position.setFromMatrixPosition(reticle.matrix);
    placedModel.quaternion.setFromRotationMatrix(reticle.matrix);
    scene.add(placedModel);
    buildButtons();
    if (byUrl) {
      const oc = document.getElementById('order-button-container');
      oc.style.display = 'block';
      document.getElementById('order-button').onclick = ()=>{ location.href = byUrl; };
    }
  }

  function buildButtons() {
    const cb = document.getElementById('model-buttons');
    cb.innerHTML = '';
    modelList.forEach((e,i)=>{
      if (!modelObjects[i]) return;
      let btn = document.createElement('button');
      btn.textContent = e.label;
      btn.onclick = ()=> replaceModel(modelObjects[i]);
      cb.appendChild(btn);
    });
    cb.style.display = 'block';
  }

  function replaceModel(m) {
    if (!placedModel) return;
    const { position, rotation, scale } = placedModel;
    scene.remove(placedModel);
    placedModel = m.clone();
    placedModel.position.copy(position);
    placedModel.rotation.copy(rotation);
    placedModel.scale.copy(scale);
    scene.add(placedModel);
  }

  function animate() {
    renderer.setAnimationLoop(render);
  }

  function render(timestamp, frame) {
    if (frame && !placedModel) {
      const session = renderer.xr.getSession();
      const refSpace = renderer.xr.getReferenceSpace();
      if (!hitTestSourceRequested) {
        session.requestReferenceSpace('viewer')
          .then(rs=>session.requestHitTestSource({ space: rs }))
          .then(src=>{ hitTestSource = src; });
        session.addEventListener('end', ()=> {
          hitTestSourceRequested = false; hitTestSource = null;
        });
        hitTestSourceRequested = true;
      }
      if (hitTestSource) {
        const hits = frame.getHitTestResults(hitTestSource);
        if (hits.length) {
          const pose = hits[0].getPose(refSpace);
          reticle.visible = true;
          reticle.matrix.fromArray(pose.transform.matrix);
        } else reticle.visible = false;
      }
    }
    renderer.render(scene, camera);
  }
  </script>
</body>
</html>
